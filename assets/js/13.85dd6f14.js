(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{212:function(a,t,s){"use strict";s.r(t);var r=s(0),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"掘金小册《前端性能优化原理与实践》阅读总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#掘金小册《前端性能优化原理与实践》阅读总结"}},[a._v("#")]),a._v(" 掘金小册《前端性能优化原理与实践》阅读总结")]),a._v(" "),s("h2",{attrs:{id:"小册的脑图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小册的脑图"}},[a._v("#")]),a._v(" 小册的脑图")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://s2.ax1x.com/2020/02/06/1cVeaT.png",alt:"1cVeaT.png"}})]),a._v(" "),s("h2",{attrs:{id:"图片相关优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图片相关优化"}},[a._v("#")]),a._v(" 图片相关优化")]),a._v(" "),s("p",[a._v("压缩图片的体积，是以牺牲一部分成像质量为代价的，所以图片相关的优化\n实际上是寻找一个质量与性能之间的平衡点。")]),a._v(" "),s("h3",{attrs:{id:"像素的基础知识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#像素的基础知识"}},[a._v("#")]),a._v(" 像素的基础知识")]),a._v(" "),s("p",[a._v("在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的。 一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。")]),a._v(" "),s("h3",{attrs:{id:"jpg-jepg"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jpg-jepg"}},[a._v("#")]),a._v(" JPG/JEPG")]),a._v(" "),s("h4",{attrs:{id:"特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),s("p",[a._v("有损压缩，体积小，加载快，不支持透明化")]),a._v(" "),s("h4",{attrs:{id:"优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),s("p",[a._v("使用JPG呈现大图，既能保住图片的质量，又不会使得图片体积过大。")]),a._v(" "),s("h4",{attrs:{id:"缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),s("p",[a._v("在处理矢量图形和logo等线条感比较强，颜色对比强烈的图像时，人为压缩导致的图片模糊会很明显，且不支持透明处理")]),a._v(" "),s("h4",{attrs:{id:"应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[a._v("#")]),a._v(" 应用")]),a._v(" "),s("p",[a._v("作为大的背景图，轮播图或者Banner图出现。")]),a._v(" "),s("h3",{attrs:{id:"png-8与png-24（8位与24位）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#png-8与png-24（8位与24位）"}},[a._v("#")]),a._v(" PNG-8与PNG-24（8位与24位）")]),a._v(" "),s("h4",{attrs:{id:"特点-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点-2"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),s("p",[a._v("无损压缩，质量高，体积大，支持透明")]),a._v(" "),s("h4",{attrs:{id:"优点-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),s("p",[a._v("更具色彩表现力，对线条处理更细腻，对透明度有良好支持，弥补了JPG的局限性。")]),a._v(" "),s("h4",{attrs:{id:"缺点-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),s("p",[a._v("体积太大")]),a._v(" "),s("h4",{attrs:{id:"应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[a._v("#")]),a._v(" 应用场景")]),a._v(" "),s("p",[a._v("用来呈现一些小的Logo，小图片，颜色简单且对比强烈的图片或者背景等。")]),a._v(" "),s("h3",{attrs:{id:"svg"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#svg"}},[a._v("#")]),a._v(" SVG")]),a._v(" "),s("h4",{attrs:{id:"特点-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点-3"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),s("p",[a._v("文本文件，体积小，不失真，兼容性好，可编程。")]),a._v(" "),s("h4",{attrs:{id:"优点-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点-3"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),s("p",[a._v("文件体积更小，可压缩性更强，图片可无限放大而不失真，足以适配n种分辨率。")]),a._v(" "),s("h4",{attrs:{id:"使用方式与场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用方式与场景"}},[a._v("#")]),a._v(" 使用方式与场景")]),a._v(" "),s("pre",[s("code",[a._v('<svg xmlns="http://www.w3.org/2000/svg"   width="200" height="200">      \n   <circle cx="50" cy="50" r="50" ></circle>    \n </svg> \n<img src="文件名.svg" alt="">\n')])]),a._v(" "),s("p",[a._v("一般用于做一些矢量图。")]),a._v(" "),s("h3",{attrs:{id:"base64"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#base64"}},[a._v("#")]),a._v(" Base64")]),a._v(" "),s("h4",{attrs:{id:"特点-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点-4"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),s("p",[a._v("文本文件，依赖编码，小图标解决方案，作为雪碧图的补充方案使用。")]),a._v(" "),s("h4",{attrs:{id:"优点-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点-4"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),s("p",[a._v("Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，即不用单独请求图片，从而减少 HTTP 请求的次数。")]),a._v(" "),s("h4",{attrs:{id:"缺点-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点-3"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),s("p",[a._v("Base64 编码后，图片大小会膨胀为原文件的 4/3（这是由 Base64 的编码原理决定的）。 如果我们把大图也编码到 HTML 或 CSS 文件中，后者的体积会明显增加，即便我们减少了 HTTP 请 求，也无法弥补这庞大的体积带来的性能开销，得不偿失。 所以在选中Base64编码时需要衡量究竟体积带来的损耗更大，还是多一次请求的损耗更大。")]),a._v(" "),s("h4",{attrs:{id:"webp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webp"}},[a._v("#")]),a._v(" WebP")]),a._v(" "),s("h4",{attrs:{id:"特点-5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点-5"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),s("p",[a._v("全能型选手，兼容性差")]),a._v(" "),s("h4",{attrs:{id:"优点-5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点-5"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),s("p",[a._v("支持透明，支持动图，支持丰富色彩，有损Webp相比同类JPEG图像小25-34%，无损Webp支持透明度，仅需22% 的额外字节。")]),a._v(" "),s("h4",{attrs:{id:"缺点-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点-4"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),s("p",[a._v("兼容性差，很多浏览器不支持，编码同样质量的WebP文件会占用更多计算机资源，会增加服务器负担。")]),a._v(" "),s("h4",{attrs:{id:"应用场景-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-2"}},[a._v("#")]),a._v(" 应用场景")]),a._v(" "),s("p",[a._v("常常需要伴随降级处理")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://s2.ax1x.com/2020/02/06/1cZa7V.png",alt:"1cZa7V.png"}})]),a._v(" "),s("h2",{attrs:{id:"浏览器缓存机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存机制"}},[a._v("#")]),a._v(" 浏览器缓存机制")]),a._v(" "),s("p",[a._v("下面这张图展示了浏览器所有的缓存类型\n"),s("img",{attrs:{src:"https://s2.ax1x.com/2020/02/06/1cZhtO.png",alt:"1cZhtO.png"}})]),a._v(" "),s("h3",{attrs:{id:"http-cache"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-cache"}},[a._v("#")]),a._v(" HTTP Cache")]),a._v(" "),s("p",[a._v("HTTP缓存有强缓存和协商缓存两种，强缓存优先级较高，在命中强缓存失败的情况下，才会走协商缓存。")]),a._v(" "),s("h4",{attrs:{id:"强缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[a._v("#")]),a._v(" 强缓存")]),a._v(" "),s("h5",{attrs:{id:"特征"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特征"}},[a._v("#")]),a._v(" 特征")]),a._v(" "),s("p",[a._v("当请求再次发出时，浏览器会根据其中的expires和cache-control判断目标资源是否命中强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信，所谓命中就是指资源未过期。")]),a._v(" "),s("h5",{attrs:{id:"相应字段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#相应字段"}},[a._v("#")]),a._v(" 相应字段")]),a._v(" "),s("h6",{attrs:{id:"expires"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[a._v("#")]),a._v(" Expires")]),a._v(" "),s("p",[a._v("旧解决方案，值为一个时间戳，目前继续使用expires的唯一目的就是向下兼容")]),a._v(" "),s("pre",[s("code",[a._v("expires: Wed, 11 Sep 2019 16:12:18 GMT\n")])]),a._v(" "),s("p",[s("strong",[a._v("缺点")]),a._v("：极度依赖于本地时间，如果服务端和客户端的时间设置不同，或者直接动手修改客户端时间，那么expires可能违背于我们的预期。")]),a._v(" "),s("h6",{attrs:{id:"cache-control"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[a._v("#")]),a._v(" Cache-control")]),a._v(" "),s("p",[a._v("是expires的完全替代方案，cache-cotnrol可以容纳多个属性，一些常用属性如下：")]),a._v(" "),s("ul",[s("li",[a._v("max-age=3600")])]),a._v(" "),s("p",[a._v("一个时间段，规定资源的过期时间")]),a._v(" "),s("ul",[s("li",[a._v("s-maxage=3153000")])]),a._v(" "),s("p",[a._v("优先级比max-age高，用于表示cache服务器上（比如cache CDN）中的缓存的有效时间，并只对public缓存有效。（仅在代理服务器生效，客户端会忽略）")]),a._v(" "),s("ul",[s("li",[a._v("public/priviare")])]),a._v(" "),s("p",[a._v("用以标识资源能否被代理服务器缓存，前者表示既可以被代理服务器缓存，又可以被浏览器缓存，后者则表示只接受浏览器缓存（就算没设置public，只要设置了s-maxage那么代理服务器就一定能缓存）")]),a._v(" "),s("ul",[s("li",[a._v("no-cache")])]),a._v(" "),s("p",[a._v("表示绕开浏览器，直接走协商缓存")]),a._v(" "),s("ul",[s("li",[a._v("no-store")])]),a._v(" "),s("p",[a._v("表示不使用任何缓存策略，每次都要从服务端下载完整响应")]),a._v(" "),s("ul",[s("li",[a._v("immutable")])]),a._v(" "),s("p",[a._v("防止用户点击刷新页面又向服务器发送请求，而不管强缓存的时间是否过期，添加之后就会强制从本地磁盘读取资源了。")]),a._v(" "),s("h4",{attrs:{id:"协商缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[a._v("#")]),a._v(" 协商缓存")]),a._v(" "),s("h5",{attrs:{id:"特征-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特征-2"}},[a._v("#")]),a._v(" 特征")]),a._v(" "),s("p",[a._v("浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求下载资源还是从本地获取缓存的资源，如果服务端提示资源未改动（Not Modified），资源会被重定向到浏览器缓存，返回304状态码。")]),a._v(" "),s("p",[a._v("相应字段：")]),a._v(" "),s("h6",{attrs:{id:"last-modified"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#last-modified"}},[a._v("#")]),a._v(" Last-Modified")]),a._v(" "),s("p",[a._v("值为一个时间戳，如果启动了协商缓存，它会在首次请求时随着响应头返回")]),a._v(" "),s("pre",[s("code",[a._v("Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT\n")])]),a._v(" "),s("p",[a._v("之后每次请求都会带上一个叫If-Modified-Since的时间戳字段，其值为response返回的last-modified值，服务器接收到这个值后，会看资源在服务器的最后修改时间是否一致，从而判断资源是否变化，并决定是否添加新的last-modified或者是返回304响应并读取缓存")]),a._v(" "),s("p",[s("strong",[a._v("缺点")]),a._v("：编辑了文件，但是文件内容没有改变，则这个资源也会被当做新资源，进而引发一次新的响应，客户端重新发送请求下载；If-Modified-Since只能检查到以秒为最小计量单位的时间差，如果修改文件速度过快（小于1秒），那就检测不到变化，从而不会重新请求。")]),a._v(" "),s("h5",{attrs:{id:"etag"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[a._v("#")]),a._v(" Etag")]),a._v(" "),s("p",[a._v("Etag是由服务器为每个资源生成的唯一的标识字符串，基于文件内容编码，只要文件内容不同，对应的etag就不同，完美解决last-modified的问题，前后端交互方式和last-modified一样，优先级比last-modified高。")]),a._v(" "),s("p",[s("strong",[a._v("缺点")]),a._v("：生成过程需要服务器额外付出开销，会影响服务端性能")]),a._v(" "),s("h4",{attrs:{id:"http缓存决策建议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http缓存决策建议"}},[a._v("#")]),a._v(" HTTP缓存决策建议")]),a._v(" "),s("p",[a._v("当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑 是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该 资源的过期时间，设置对应的 max-age 和 s-maxage 值；后，配置协商缓存需要用到的 Etag、LastModiﬁed 等参数。")]),a._v(" "),s("h3",{attrs:{id:"memory-cache"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#memory-cache"}},[a._v("#")]),a._v(" Memory Cache")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器先尝试去命中的一种缓存。 从效率上来说，它是响应速度快的一种缓存。")])]),a._v(" "),s("li",[s("p",[a._v("内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内 存里的数据也将不复存在。")])]),a._v(" "),s("li",[s("p",[a._v("内存比较小，所以存进去的都是较小的资源，比如base64格式的图片。")])])]),a._v(" "),s("h3",{attrs:{id:"service-worker-cache"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#service-worker-cache"}},[a._v("#")]),a._v(" Service Worker Cache")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM，独立使其无法干扰页面的性能，可以用于实现离线缓存，消息推送和网络代理等功能。")])]),a._v(" "),s("li",[s("p",[a._v("Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实 现离线存储的重要先决条件。")])]),a._v(" "),s("li",[s("p",[a._v("Server Worker 对协议是有要求的，必须以 https 协议为前提。")])])]),a._v(" "),s("h3",{attrs:{id:"push-cache"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#push-cache"}},[a._v("#")]),a._v(" Push Cache")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。")])]),a._v(" "),s("li",[s("p",[a._v("Push Cache 是缓存的后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。")])]),a._v(" "),s("li",[s("p",[a._v("Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。")])]),a._v(" "),s("li",[s("p",[a._v("不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。")])])]),a._v(" "),s("h2",{attrs:{id:"本地缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#本地缓存"}},[a._v("#")]),a._v(" 本地缓存")]),a._v(" "),s("h3",{attrs:{id:"cookie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[a._v("#")]),a._v(" cookie")]),a._v(" "),s("p",[a._v("用以解决HTTP无状态问题，大小上限为4k，常用来配合session做一些登录状态缓存之类。")]),a._v(" "),s("h4",{attrs:{id:"生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[a._v("#")]),a._v(" 生命周期")]),a._v(" "),s("p",[a._v("由后端设置过期时间")]),a._v(" "),s("h4",{attrs:{id:"作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[a._v("#")]),a._v(" 作用域")]),a._v(" "),s("p",[a._v("所有同源页面")]),a._v(" "),s("h3",{attrs:{id:"local-storage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#local-storage"}},[a._v("#")]),a._v(" local storage")]),a._v(" "),s("h4",{attrs:{id:"生命周期-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期-2"}},[a._v("#")]),a._v(" 生命周期")]),a._v(" "),s("p",[a._v("Local Storage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除。")]),a._v(" "),s("h4",{attrs:{id:"应用场景-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-3"}},[a._v("#")]),a._v(" 应用场景")]),a._v(" "),s("p",[a._v("用它来存储一些内 容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串以及一些不常更新的css，js等静态资源")]),a._v(" "),s("h3",{attrs:{id:"session-storage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#session-storage"}},[a._v("#")]),a._v(" session storage")]),a._v(" "),s("h4",{attrs:{id:"生命周期-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期-3"}},[a._v("#")]),a._v(" 生命周期")]),a._v(" "),s("p",[a._v("Session Storage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。")]),a._v(" "),s("h4",{attrs:{id:"特点与作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点与作用域"}},[a._v("#")]),a._v(" 特点与作用域")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("页面刷新不会消除数据")])]),a._v(" "),s("li",[s("p",[a._v("只有在当前页面打开的链接，才能访问到session storage的数据（跳过去后修改session storage不会生效，因为返回原页面又会被修改一次）")])]),a._v(" "),s("li",[s("p",[a._v("使用window.open打开页面和改变localtion.href方式都可以获取到sessionStorage内部的数据")])])]),a._v(" "),s("h4",{attrs:{id:"应用场景-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-4"}},[a._v("#")]),a._v(" 应用场景")]),a._v(" "),s("p",[a._v("Session Storage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话， 当你开启新的会话时，它也需要相应的更新或释放。比如微博的 Session Storage 就主要是存储你本次会话的浏览足迹")]),a._v(" "),s("h3",{attrs:{id:"区别与共性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#区别与共性"}},[a._v("#")]),a._v(" 区别与共性")]),a._v(" "),s("p",[a._v("Local Storage、Session Storage 和 Cookie 都遵循同源策略。cookie容量较小，local storage和session storage的存储容量较大，达到5-10M")]),a._v(" "),s("h3",{attrs:{id:"indexdb"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#indexdb"}},[a._v("#")]),a._v(" IndexDB")]),a._v(" "),s("p",[a._v("IndexDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小 闹级别了。理论上来说，IndexDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字 符串，还可以存储二进制数据。")]),a._v(" "),s("h4",{attrs:{id:"应用场景-5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-5"}},[a._v("#")]),a._v(" 应用场景")]),a._v(" "),s("p",[a._v("当数据规模上升到LocalStorage无法解决的程度，就可以用IndexDB来解决")]),a._v(" "),s("h2",{attrs:{id:"cdn相关"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cdn相关"}},[a._v("#")]),a._v(" CDN相关")]),a._v(" "),s("h3",{attrs:{id:"cdn是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cdn是什么"}},[a._v("#")]),a._v(" CDN是什么")]),a._v(" "),s("p",[a._v("CDN是一组分布在各个地区的服务器。这些服务器保存着数据的副本，这样服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。")]),a._v(" "),s("h3",{attrs:{id:"cdn的核心功能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cdn的核心功能"}},[a._v("#")]),a._v(" CDN的核心功能")]),a._v(" "),s("h4",{attrs:{id:"缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[a._v("#")]),a._v(" 缓存")]),a._v(" "),s("p",[a._v("缓存就是我们把资源拷贝一份到CDN服务器（除了根服务器的其他服务器）上")]),a._v(" "),s("h4",{attrs:{id:"回源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回源"}},[a._v("#")]),a._v(" 回源")]),a._v(" "),s("p",[a._v("回源就是指CDN发现自己没有某个资源（或者缓存的资源过期），则转头去向根服务器去获取这个资源")]),a._v(" "),s("h4",{attrs:{id:"场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[a._v("#")]),a._v(" 场景")]),a._v(" "),s("p",[a._v("一般是静态资源才会走CDN，因为静态资源本身具有访问频率高、承接流量大的特点")]),a._v(" "),s("h4",{attrs:{id:"cdn的域名带来的优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cdn的域名带来的优化"}},[a._v("#")]),a._v(" CDN的域名带来的优化")]),a._v(" "),s("p",[a._v("把静态资源和主页面置于不同的域名下，完美地避免了不必要的 Cookie 的出现！")]),a._v(" "),s("h2",{attrs:{id:"服务端渲染和客户端渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染和客户端渲染"}},[a._v("#")]),a._v(" 服务端渲染和客户端渲染")]),a._v(" "),s("h3",{attrs:{id:"客户端渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#客户端渲染"}},[a._v("#")]),a._v(" 客户端渲染")]),a._v(" "),s("p",[a._v("客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。这种特性使得客户端渲染的源代码总是特别简洁，页面上呈现的内容，你在 html 源文件里里找不到——这正是它的特点。")]),a._v(" "),s("h3",{attrs:{id:"服务端渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染"}},[a._v("#")]),a._v(" 服务端渲染")]),a._v(" "),s("p",[a._v("服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串， 然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了 生成 DOM 内容自己再去跑一遍 JS 代码。 使用服务端渲染的网站，可以说是“所见即所得”，页面上呈现的内容，我们在 html 源文件里也能找到。")]),a._v(" "),s("h3",{attrs:{id:"服务端渲染解决的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染解决的问题"}},[a._v("#")]),a._v(" 服务端渲染解决的问题")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("有利于SEO")])]),a._v(" "),s("li",[s("p",[a._v("加快首屏渲染")])])]),a._v(" "),s("h3",{attrs:{id:"服务端应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务端应用场景"}},[a._v("#")]),a._v(" 服务端应用场景")]),a._v(" "),s("p",[a._v("服务端渲染本质上是本该浏览器做的事情，分担给服务器去，除非网页对性能要求太高了，以至于所有的招式都用完了，性能表现还是不尽人意，才考虑服务端渲染。")]),a._v(" "),s("h2",{attrs:{id:"浏览器渲染相关"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染相关"}},[a._v("#")]),a._v(" 浏览器渲染相关")]),a._v(" "),s("h3",{attrs:{id:"浏览器内核的核心部件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器内核的核心部件"}},[a._v("#")]),a._v(" 浏览器内核的核心部件")]),a._v(" "),s("h4",{attrs:{id:"html-解释器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html-解释器"}},[a._v("#")]),a._v(" HTML 解释器")]),a._v(" "),s("p",[a._v("将 HTML 文档经过词法分析输出 DOM 树。")]),a._v(" "),s("h4",{attrs:{id:"css-解释器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-解释器"}},[a._v("#")]),a._v(" CSS 解释器")]),a._v(" "),s("p",[a._v("解析 CSS 文档, 生成样式规则。")]),a._v(" "),s("h4",{attrs:{id:"图层布局计算模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图层布局计算模块"}},[a._v("#")]),a._v(" 图层布局计算模块")]),a._v(" "),s("p",[a._v("布局计算每个对象的精确位置和大小。")]),a._v(" "),s("h4",{attrs:{id:"视图绘制模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#视图绘制模块"}},[a._v("#")]),a._v(" 视图绘制模块")]),a._v(" "),s("p",[a._v("进行具体节点的图像绘制，将像素渲染到屏幕上。")]),a._v(" "),s("h4",{attrs:{id:"javascript-引擎"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript-引擎"}},[a._v("#")]),a._v(" JavaScript 引擎")]),a._v(" "),s("p",[a._v("编译执行 Javascript 代码。")]),a._v(" "),s("h3",{attrs:{id:"浏览器渲染过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染过程"}},[a._v("#")]),a._v(" 浏览器渲染过程")]),a._v(" "),s("h4",{attrs:{id:"解析html"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解析html"}},[a._v("#")]),a._v(" 解析HTML")]),a._v(" "),s("p",[a._v("在这一步浏览器将HTML文件从上至下解析，过程中会加载页面渲染所需的各种外部资源请求，如css,js，图片等。在这一步会生成DOM树。")]),a._v(" "),s("h4",{attrs:{id:"计算样式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算样式"}},[a._v("#")]),a._v(" 计算样式")]),a._v(" "),s("p",[a._v("浏览器识别并加载CSS样式，解析生成CSSOM树（该解析过程是与DOM的解析并行的）并与DOM树合并，最终在页面生成render渲染树（注意：伪元素会被构建到DOM树中）。")]),a._v(" "),s("h4",{attrs:{id:"计算图层布局"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算图层布局"}},[a._v("#")]),a._v(" 计算图层布局")]),a._v(" "),s("p",[a._v("从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕 上的精确坐标，我们便得到了基于渲染树的布局渲染树。")]),a._v(" "),s("h4",{attrs:{id:"绘制图层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#绘制图层"}},[a._v("#")]),a._v(" 绘制图层")]),a._v(" "),s("p",[a._v("浏览器根据DOM代码结果，把每一个页面图层转换为像素，并对所有媒体文件解码。")]),a._v(" "),s("h4",{attrs:{id:"整合图层得到页面"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#整合图层得到页面"}},[a._v("#")]),a._v(" 整合图层得到页面")]),a._v(" "),s("p",[a._v("合并所有图层，将数据从CPU输出至GPU并绘制到屏幕上。")]),a._v(" "),s("h3",{attrs:{id:"css优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css优化"}},[a._v("#")]),a._v(" CSS优化")]),a._v(" "),s("h4",{attrs:{id:"小知识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小知识"}},[a._v("#")]),a._v(" 小知识")]),a._v(" "),s("p",[a._v("CSS 引擎查找样式表，对每条规则都 按从右到左的顺序去匹配，比如#box li{}，这种写法在浏览器中是先找到所有的li元素，再查看他的父元素的id是否为box，而不是按我们的常规思路先定位id 再在id里面找。")]),a._v(" "),s("h4",{attrs:{id:"优化点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化点"}},[a._v("#")]),a._v(" 优化点")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("避免使用通配符，只对需要用到的元素进行选择。")])]),a._v(" "),s("li",[s("p",[a._v("关注可以通过继承实现的属性，避免重复匹配重复定义。")])]),a._v(" "),s("li",[s("p",[a._v("少用标签选择器。如果可以，用类选择器替代。")])]),a._v(" "),s("li",[s("p",[a._v("减少嵌套。后代选择器的开销是高的，因此我们应该尽量将选择器的深度降到低（高不要超 过三层），尽可能使用类来关联每一个标签元素。")])])]),a._v(" "),s("h3",{attrs:{id:"css与js的加载顺序优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css与js的加载顺序优化"}},[a._v("#")]),a._v(" CSS与JS的加载顺序优化")]),a._v(" "),s("h4",{attrs:{id:"css的阻塞"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css的阻塞"}},[a._v("#")]),a._v(" CSS的阻塞")]),a._v(" "),s("p",[a._v("DOM 和 CSSOM 合力才能构建渲染树。这一点会给性能造成严重影响：默认情况下，CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。即便 DOM 已经解析完毕了，只要 CSSOM 没构建完成，那么就不能渲染。（这样的好处是避免了没有样式的页面显示）")]),a._v(" "),s("h4",{attrs:{id:"css的加载优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css的加载优化"}},[a._v("#")]),a._v(" CSS的加载优化")]),a._v(" "),s("p",[a._v("为了达到更快渲染页面的目的，应该让CSS尽快的加载，而CSS的引入是通过link或者style的方式来进行的（都放在head里面为了尽快加载），然后资源放在CDN上，尽快的下载。")]),a._v(" "),s("h4",{attrs:{id:"js阻塞"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js阻塞"}},[a._v("#")]),a._v(" JS阻塞")]),a._v(" "),s("p",[a._v("JS 引擎是独立于渲染引擎存在的。我们的 JS 代码在文档的何处插入，就在何处执行。 所以当HTML解析器加载到script标签时，会暂停渲染过程，将控制器交给JS引擎，这就导致了阻塞。")]),a._v(" "),s("h4",{attrs:{id:"js的加载优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js的加载优化"}},[a._v("#")]),a._v(" JS的加载优化")]),a._v(" "),s("h5",{attrs:{id:"defer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#defer"}},[a._v("#")]),a._v(" defer")]),a._v(" "),s("p",[a._v("在script添加defer属性，可以让JS的加载变成异步，等整个文档解析完成，被标记了defer的JS文件才开始依次执行")]),a._v(" "),s("h5",{attrs:{id:"async"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async"}},[a._v("#")]),a._v(" async")]),a._v(" "),s("p",[a._v("在script标签添加async属性，，也是异步加载JS，不过是加载结束就立即执行，而不用等文档加载完成，且不会保证执行顺序。")]),a._v(" "),s("h5",{attrs:{id:"应用选择"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用选择"}},[a._v("#")]),a._v(" 应用选择")]),a._v(" "),s("p",[a._v("一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。")]),a._v(" "),s("h4",{attrs:{id:"回流与重绘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回流与重绘"}},[a._v("#")]),a._v(" 回流与重绘")]),a._v(" "),s("h5",{attrs:{id:"回流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回流"}},[a._v("#")]),a._v(" 回流")]),a._v(" "),s("p",[a._v("当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素 等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响）， 然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。 如背景色、文字色、可见性(可见性这里特指形如"),s("code",[a._v("visibility: hidden")]),a._v("这样不改变元素位置和存在 性的、单纯针对可见性的操作，注意与display:none进行区分)等都会触发回流。")]),a._v(" "),s("p",[s("strong",[a._v("注意")]),a._v("："),s("code",[a._v("oﬀsetTop、oﬀsetLeft、 oﬀsetWidth、oﬀsetHeight、scrollTop、 scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight， getComputedStyle")]),a._v(" 这些值有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流。")]),a._v(" "),s("h4",{attrs:{id:"重绘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[a._v("#")]),a._v(" 重绘")]),a._v(" "),s("p",[a._v("当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回 流环节）。这个过程叫做重绘。")]),a._v(" "),s("h5",{attrs:{id:"关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关系"}},[a._v("#")]),a._v(" 关系")]),a._v(" "),s("p",[a._v("回流一定会引发重绘，重绘不一定会引发回流。")]),a._v(" "),s("h4",{attrs:{id:"优化切入点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化切入点"}},[a._v("#")]),a._v(" 优化切入点")]),a._v(" "),s("p",[a._v("考虑JS 的运行速度，比 DOM 快得多这个特性。我们减少 DOM 操作的核心思路，就是让 JS 去给 DOM 分压。")]),a._v(" "),s("h4",{attrs:{id:"documentfragment"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#documentfragment"}},[a._v("#")]),a._v(" DocumentFragment")]),a._v(" "),s("p",[a._v("DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作 （reﬂow），且不会导致性能等问题。")]),a._v(" "),s("h4",{attrs:{id:"规避回流与重绘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#规避回流与重绘"}},[a._v("#")]),a._v(" 规避回流与重绘")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("避免逐条改变样式，使用类名去合并样")])]),a._v(" "),s("li",[s("p",[a._v("用JS缓存修改结果再赋值给DOM引发最终的变化。")])]),a._v(" "),s("li",[s("p",[a._v("将 DOM “离线” ，即在修改的时候先设置为"),s("code",[a._v("display:none")]),a._v("，相当于从页面中拿掉，改完之后再变回来")])]),a._v(" "),s("li",[s("p",[a._v("Flush 队列，浏览器自己缓存了一个 ﬂush 队列，把我们触发的回流与重绘任务都塞进 去，待到队列里的任务多起来、或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队（即时性的任务flush队列会不生效）")])])]),a._v(" "),s("h4",{attrs:{id:"event-loop-与异步更新策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-与异步更新策略"}},[a._v("#")]),a._v(" Event Loop 与异步更新策略")]),a._v(" "),s("h5",{attrs:{id:"event-loop过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event-loop过程"}},[a._v("#")]),a._v(" Event Loop过程")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://xiaolee55.github.io/pages/Javascript/JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("看这里"),s("OutboundLink")],1)]),a._v(" "),s("h5",{attrs:{id:"特点-6"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点-6"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),s("p",[a._v("异步更新的特性在于它只看结果，因此渲染引擎不需要为过程买单。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://s2.ax1x.com/2020/02/06/1cuhqA.png",alt:"1cuhqA.png"}})]),a._v(" "),s("h5",{attrs:{id:"dom修改应该放在哪"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dom修改应该放在哪"}},[a._v("#")]),a._v(" DOM修改应该放在哪")]),a._v(" "),s("p",[a._v("我们更新 DOM 的时间点，应该尽可能靠近渲染的时机。当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择。 因为如果放在macro-task中，macro-task会一个个地执行，如果DOM的异步更新是写在比较靠后的macro-task中，会导致在前面宏任务渲染的时候没有其效果。")]),a._v(" "),s("blockquote",[s("p",[a._v("由于性能优化方面一直是自己的一个知识盲区，所以在掘金上购买了一本相关的小册进行学习，虽然讲解不算很深入，但是比较全面，算是对性能优化有了一个整体的认识，后面再慢慢深入实践。")])]),a._v(" "),s("p",[s("strong",[a._v("完!")])])])}),[],!1,null,null,null);t.default=v.exports}}]);