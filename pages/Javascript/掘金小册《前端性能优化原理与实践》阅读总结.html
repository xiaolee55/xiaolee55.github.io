<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>掘金小册《前端性能优化原理与实践》阅读总结 | XiaoLeeBlog</title>
    <meta name="description" content="我的文章网站">
    <link rel="icon" href="/titlelogo.png">
    
    <link rel="preload" href="/assets/css/0.styles.ec507139.css" as="style"><link rel="preload" href="/assets/js/app.8d8834a2.js" as="script"><link rel="preload" href="/assets/js/2.4111b689.js" as="script"><link rel="preload" href="/assets/js/13.85dd6f14.js" as="script"><link rel="prefetch" href="/assets/js/10.f5b7094d.js"><link rel="prefetch" href="/assets/js/11.06b0a1b9.js"><link rel="prefetch" href="/assets/js/12.a29a4b4d.js"><link rel="prefetch" href="/assets/js/14.e058b9f1.js"><link rel="prefetch" href="/assets/js/15.fa0a1b7f.js"><link rel="prefetch" href="/assets/js/16.c674646e.js"><link rel="prefetch" href="/assets/js/3.f0f9c942.js"><link rel="prefetch" href="/assets/js/4.9eed5240.js"><link rel="prefetch" href="/assets/js/5.d37db87a.js"><link rel="prefetch" href="/assets/js/6.64a418b3.js"><link rel="prefetch" href="/assets/js/7.331065bf.js"><link rel="prefetch" href="/assets/js/8.a14ac5eb.js"><link rel="prefetch" href="/assets/js/9.7e7c1c97.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ec507139.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/fe.png" alt="XiaoLeeBlog" class="logo"> <span class="site-name can-hide">XiaoLeeBlog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章" class="dropdown-title"><span class="title">文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Javascript/JS中的作用域与闭包.html" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/pages/HTML与CSS/BFC的理解与运用.html" class="nav-link">HTML与CSS</a></li></ul></div></div><div class="nav-item"><a href="/pages/folder1/test3.html" class="nav-link">我的项目</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="读书笔记" class="dropdown-title"><span class="title">读书笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/读书笔记/图解HTTP/http方法.html" class="nav-link">图解HTTP</a></li><li class="dropdown-item"><!----> <a href="/pages/读书笔记/图解HTTP/http方法.html" class="nav-link">JS忍者秘籍</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/xiaolee55" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章" class="dropdown-title"><span class="title">文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Javascript/JS中的作用域与闭包.html" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/pages/HTML与CSS/BFC的理解与运用.html" class="nav-link">HTML与CSS</a></li></ul></div></div><div class="nav-item"><a href="/pages/folder1/test3.html" class="nav-link">我的项目</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="读书笔记" class="dropdown-title"><span class="title">读书笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/读书笔记/图解HTTP/http方法.html" class="nav-link">图解HTTP</a></li><li class="dropdown-item"><!----> <a href="/pages/读书笔记/图解HTTP/http方法.html" class="nav-link">JS忍者秘籍</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/xiaolee55" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaScript基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/Javascript/JS中的作用域与闭包.html" class="sidebar-link">JS中的作用域与闭包</a></li><li><a href="/pages/Javascript/JS中的值传递.html" class="sidebar-link">JS中的值传递</a></li><li><a href="/pages/Javascript/JS中的事件循环.html" class="sidebar-link">JS中的事件循环</a></li><li><a href="/pages/Javascript/JS中的对象访问控制.html" class="sidebar-link">JS中的对象访问控制</a></li><li><a href="/pages/Javascript/JS中的类型判断.html" class="sidebar-link">JS中的类型判断</a></li><li><a href="/pages/Javascript/JS中的生成器和Promise.html" class="sidebar-link">JS中的生成器和Promise</a></li><li><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html" class="active sidebar-link">掘金小册《前端性能优化原理与实践》阅读总结.md</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#小册的脑图" class="sidebar-link">小册的脑图</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#图片相关优化" class="sidebar-link">图片相关优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#像素的基础知识" class="sidebar-link">像素的基础知识</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#jpg-jepg" class="sidebar-link">JPG/JEPG</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#png-8与png-24（8位与24位）" class="sidebar-link">PNG-8与PNG-24（8位与24位）</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#svg" class="sidebar-link">SVG</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#base64" class="sidebar-link">Base64</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#浏览器缓存机制" class="sidebar-link">浏览器缓存机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#http-cache" class="sidebar-link">HTTP Cache</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#memory-cache" class="sidebar-link">Memory Cache</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#service-worker-cache" class="sidebar-link">Service Worker Cache</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#push-cache" class="sidebar-link">Push Cache</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#本地缓存" class="sidebar-link">本地缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#cookie" class="sidebar-link">cookie</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#local-storage" class="sidebar-link">local storage</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#session-storage" class="sidebar-link">session storage</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#区别与共性" class="sidebar-link">区别与共性</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#indexdb" class="sidebar-link">IndexDB</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#cdn相关" class="sidebar-link">CDN相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#cdn是什么" class="sidebar-link">CDN是什么</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#cdn的核心功能" class="sidebar-link">CDN的核心功能</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#服务端渲染和客户端渲染" class="sidebar-link">服务端渲染和客户端渲染</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#客户端渲染" class="sidebar-link">客户端渲染</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#服务端渲染" class="sidebar-link">服务端渲染</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#服务端渲染解决的问题" class="sidebar-link">服务端渲染解决的问题</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#服务端应用场景" class="sidebar-link">服务端应用场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#浏览器渲染相关" class="sidebar-link">浏览器渲染相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#浏览器内核的核心部件" class="sidebar-link">浏览器内核的核心部件</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#浏览器渲染过程" class="sidebar-link">浏览器渲染过程</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#css优化" class="sidebar-link">CSS优化</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html#css与js的加载顺序优化" class="sidebar-link">CSS与JS的加载顺序优化</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="掘金小册《前端性能优化原理与实践》阅读总结"><a href="#掘金小册《前端性能优化原理与实践》阅读总结" class="header-anchor">#</a> 掘金小册《前端性能优化原理与实践》阅读总结</h1> <h2 id="小册的脑图"><a href="#小册的脑图" class="header-anchor">#</a> 小册的脑图</h2> <p><img src="https://s2.ax1x.com/2020/02/06/1cVeaT.png" alt="1cVeaT.png"></p> <h2 id="图片相关优化"><a href="#图片相关优化" class="header-anchor">#</a> 图片相关优化</h2> <p>压缩图片的体积，是以牺牲一部分成像质量为代价的，所以图片相关的优化
实际上是寻找一个质量与性能之间的平衡点。</p> <h3 id="像素的基础知识"><a href="#像素的基础知识" class="header-anchor">#</a> 像素的基础知识</h3> <p>在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的。 一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。</p> <h3 id="jpg-jepg"><a href="#jpg-jepg" class="header-anchor">#</a> JPG/JEPG</h3> <h4 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h4> <p>有损压缩，体积小，加载快，不支持透明化</p> <h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h4> <p>使用JPG呈现大图，既能保住图片的质量，又不会使得图片体积过大。</p> <h4 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h4> <p>在处理矢量图形和logo等线条感比较强，颜色对比强烈的图像时，人为压缩导致的图片模糊会很明显，且不支持透明处理</p> <h4 id="应用"><a href="#应用" class="header-anchor">#</a> 应用</h4> <p>作为大的背景图，轮播图或者Banner图出现。</p> <h3 id="png-8与png-24（8位与24位）"><a href="#png-8与png-24（8位与24位）" class="header-anchor">#</a> PNG-8与PNG-24（8位与24位）</h3> <h4 id="特点-2"><a href="#特点-2" class="header-anchor">#</a> 特点</h4> <p>无损压缩，质量高，体积大，支持透明</p> <h4 id="优点-2"><a href="#优点-2" class="header-anchor">#</a> 优点</h4> <p>更具色彩表现力，对线条处理更细腻，对透明度有良好支持，弥补了JPG的局限性。</p> <h4 id="缺点-2"><a href="#缺点-2" class="header-anchor">#</a> 缺点</h4> <p>体积太大</p> <h4 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h4> <p>用来呈现一些小的Logo，小图片，颜色简单且对比强烈的图片或者背景等。</p> <h3 id="svg"><a href="#svg" class="header-anchor">#</a> SVG</h3> <h4 id="特点-3"><a href="#特点-3" class="header-anchor">#</a> 特点</h4> <p>文本文件，体积小，不失真，兼容性好，可编程。</p> <h4 id="优点-3"><a href="#优点-3" class="header-anchor">#</a> 优点</h4> <p>文件体积更小，可压缩性更强，图片可无限放大而不失真，足以适配n种分辨率。</p> <h4 id="使用方式与场景"><a href="#使用方式与场景" class="header-anchor">#</a> 使用方式与场景</h4> <pre><code>&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;   width=&quot;200&quot; height=&quot;200&quot;&gt;      
   &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;50&quot; &gt;&lt;/circle&gt;    
 &lt;/svg&gt; 
&lt;img src=&quot;文件名.svg&quot; alt=&quot;&quot;&gt;
</code></pre> <p>一般用于做一些矢量图。</p> <h3 id="base64"><a href="#base64" class="header-anchor">#</a> Base64</h3> <h4 id="特点-4"><a href="#特点-4" class="header-anchor">#</a> 特点</h4> <p>文本文件，依赖编码，小图标解决方案，作为雪碧图的补充方案使用。</p> <h4 id="优点-4"><a href="#优点-4" class="header-anchor">#</a> 优点</h4> <p>Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，即不用单独请求图片，从而减少 HTTP 请求的次数。</p> <h4 id="缺点-3"><a href="#缺点-3" class="header-anchor">#</a> 缺点</h4> <p>Base64 编码后，图片大小会膨胀为原文件的 4/3（这是由 Base64 的编码原理决定的）。 如果我们把大图也编码到 HTML 或 CSS 文件中，后者的体积会明显增加，即便我们减少了 HTTP 请 求，也无法弥补这庞大的体积带来的性能开销，得不偿失。 所以在选中Base64编码时需要衡量究竟体积带来的损耗更大，还是多一次请求的损耗更大。</p> <h4 id="webp"><a href="#webp" class="header-anchor">#</a> WebP</h4> <h4 id="特点-5"><a href="#特点-5" class="header-anchor">#</a> 特点</h4> <p>全能型选手，兼容性差</p> <h4 id="优点-5"><a href="#优点-5" class="header-anchor">#</a> 优点</h4> <p>支持透明，支持动图，支持丰富色彩，有损Webp相比同类JPEG图像小25-34%，无损Webp支持透明度，仅需22% 的额外字节。</p> <h4 id="缺点-4"><a href="#缺点-4" class="header-anchor">#</a> 缺点</h4> <p>兼容性差，很多浏览器不支持，编码同样质量的WebP文件会占用更多计算机资源，会增加服务器负担。</p> <h4 id="应用场景-2"><a href="#应用场景-2" class="header-anchor">#</a> 应用场景</h4> <p>常常需要伴随降级处理</p> <p><img src="https://s2.ax1x.com/2020/02/06/1cZa7V.png" alt="1cZa7V.png"></p> <h2 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="header-anchor">#</a> 浏览器缓存机制</h2> <p>下面这张图展示了浏览器所有的缓存类型
<img src="https://s2.ax1x.com/2020/02/06/1cZhtO.png" alt="1cZhtO.png"></p> <h3 id="http-cache"><a href="#http-cache" class="header-anchor">#</a> HTTP Cache</h3> <p>HTTP缓存有强缓存和协商缓存两种，强缓存优先级较高，在命中强缓存失败的情况下，才会走协商缓存。</p> <h4 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h4> <h5 id="特征"><a href="#特征" class="header-anchor">#</a> 特征</h5> <p>当请求再次发出时，浏览器会根据其中的expires和cache-control判断目标资源是否命中强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信，所谓命中就是指资源未过期。</p> <h5 id="相应字段"><a href="#相应字段" class="header-anchor">#</a> 相应字段</h5> <h6 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h6> <p>旧解决方案，值为一个时间戳，目前继续使用expires的唯一目的就是向下兼容</p> <pre><code>expires: Wed, 11 Sep 2019 16:12:18 GMT
</code></pre> <p><strong>缺点</strong>：极度依赖于本地时间，如果服务端和客户端的时间设置不同，或者直接动手修改客户端时间，那么expires可能违背于我们的预期。</p> <h6 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> Cache-control</h6> <p>是expires的完全替代方案，cache-cotnrol可以容纳多个属性，一些常用属性如下：</p> <ul><li>max-age=3600</li></ul> <p>一个时间段，规定资源的过期时间</p> <ul><li>s-maxage=3153000</li></ul> <p>优先级比max-age高，用于表示cache服务器上（比如cache CDN）中的缓存的有效时间，并只对public缓存有效。（仅在代理服务器生效，客户端会忽略）</p> <ul><li>public/priviare</li></ul> <p>用以标识资源能否被代理服务器缓存，前者表示既可以被代理服务器缓存，又可以被浏览器缓存，后者则表示只接受浏览器缓存（就算没设置public，只要设置了s-maxage那么代理服务器就一定能缓存）</p> <ul><li>no-cache</li></ul> <p>表示绕开浏览器，直接走协商缓存</p> <ul><li>no-store</li></ul> <p>表示不使用任何缓存策略，每次都要从服务端下载完整响应</p> <ul><li>immutable</li></ul> <p>防止用户点击刷新页面又向服务器发送请求，而不管强缓存的时间是否过期，添加之后就会强制从本地磁盘读取资源了。</p> <h4 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h4> <h5 id="特征-2"><a href="#特征-2" class="header-anchor">#</a> 特征</h5> <p>浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求下载资源还是从本地获取缓存的资源，如果服务端提示资源未改动（Not Modified），资源会被重定向到浏览器缓存，返回304状态码。</p> <p>相应字段：</p> <h6 id="last-modified"><a href="#last-modified" class="header-anchor">#</a> Last-Modified</h6> <p>值为一个时间戳，如果启动了协商缓存，它会在首次请求时随着响应头返回</p> <pre><code>Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT
</code></pre> <p>之后每次请求都会带上一个叫If-Modified-Since的时间戳字段，其值为response返回的last-modified值，服务器接收到这个值后，会看资源在服务器的最后修改时间是否一致，从而判断资源是否变化，并决定是否添加新的last-modified或者是返回304响应并读取缓存</p> <p><strong>缺点</strong>：编辑了文件，但是文件内容没有改变，则这个资源也会被当做新资源，进而引发一次新的响应，客户端重新发送请求下载；If-Modified-Since只能检查到以秒为最小计量单位的时间差，如果修改文件速度过快（小于1秒），那就检测不到变化，从而不会重新请求。</p> <h5 id="etag"><a href="#etag" class="header-anchor">#</a> Etag</h5> <p>Etag是由服务器为每个资源生成的唯一的标识字符串，基于文件内容编码，只要文件内容不同，对应的etag就不同，完美解决last-modified的问题，前后端交互方式和last-modified一样，优先级比last-modified高。</p> <p><strong>缺点</strong>：生成过程需要服务器额外付出开销，会影响服务端性能</p> <h4 id="http缓存决策建议"><a href="#http缓存决策建议" class="header-anchor">#</a> HTTP缓存决策建议</h4> <p>当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑 是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该 资源的过期时间，设置对应的 max-age 和 s-maxage 值；后，配置协商缓存需要用到的 Etag、LastModiﬁed 等参数。</p> <h3 id="memory-cache"><a href="#memory-cache" class="header-anchor">#</a> Memory Cache</h3> <ul><li><p>MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器先尝试去命中的一种缓存。 从效率上来说，它是响应速度快的一种缓存。</p></li> <li><p>内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内 存里的数据也将不复存在。</p></li> <li><p>内存比较小，所以存进去的都是较小的资源，比如base64格式的图片。</p></li></ul> <h3 id="service-worker-cache"><a href="#service-worker-cache" class="header-anchor">#</a> Service Worker Cache</h3> <ul><li><p>Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM，独立使其无法干扰页面的性能，可以用于实现离线缓存，消息推送和网络代理等功能。</p></li> <li><p>Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实 现离线存储的重要先决条件。</p></li> <li><p>Server Worker 对协议是有要求的，必须以 https 协议为前提。</p></li></ul> <h3 id="push-cache"><a href="#push-cache" class="header-anchor">#</a> Push Cache</h3> <ul><li><p>Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。</p></li> <li><p>Push Cache 是缓存的后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。</p></li> <li><p>Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。</p></li> <li><p>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。</p></li></ul> <h2 id="本地缓存"><a href="#本地缓存" class="header-anchor">#</a> 本地缓存</h2> <h3 id="cookie"><a href="#cookie" class="header-anchor">#</a> cookie</h3> <p>用以解决HTTP无状态问题，大小上限为4k，常用来配合session做一些登录状态缓存之类。</p> <h4 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h4> <p>由后端设置过期时间</p> <h4 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h4> <p>所有同源页面</p> <h3 id="local-storage"><a href="#local-storage" class="header-anchor">#</a> local storage</h3> <h4 id="生命周期-2"><a href="#生命周期-2" class="header-anchor">#</a> 生命周期</h4> <p>Local Storage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除。</p> <h4 id="应用场景-3"><a href="#应用场景-3" class="header-anchor">#</a> 应用场景</h4> <p>用它来存储一些内 容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串以及一些不常更新的css，js等静态资源</p> <h3 id="session-storage"><a href="#session-storage" class="header-anchor">#</a> session storage</h3> <h4 id="生命周期-3"><a href="#生命周期-3" class="header-anchor">#</a> 生命周期</h4> <p>Session Storage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</p> <h4 id="特点与作用域"><a href="#特点与作用域" class="header-anchor">#</a> 特点与作用域</h4> <ul><li><p>页面刷新不会消除数据</p></li> <li><p>只有在当前页面打开的链接，才能访问到session storage的数据（跳过去后修改session storage不会生效，因为返回原页面又会被修改一次）</p></li> <li><p>使用window.open打开页面和改变localtion.href方式都可以获取到sessionStorage内部的数据</p></li></ul> <h4 id="应用场景-4"><a href="#应用场景-4" class="header-anchor">#</a> 应用场景</h4> <p>Session Storage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话， 当你开启新的会话时，它也需要相应的更新或释放。比如微博的 Session Storage 就主要是存储你本次会话的浏览足迹</p> <h3 id="区别与共性"><a href="#区别与共性" class="header-anchor">#</a> 区别与共性</h3> <p>Local Storage、Session Storage 和 Cookie 都遵循同源策略。cookie容量较小，local storage和session storage的存储容量较大，达到5-10M</p> <h3 id="indexdb"><a href="#indexdb" class="header-anchor">#</a> IndexDB</h3> <p>IndexDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小 闹级别了。理论上来说，IndexDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字 符串，还可以存储二进制数据。</p> <h4 id="应用场景-5"><a href="#应用场景-5" class="header-anchor">#</a> 应用场景</h4> <p>当数据规模上升到LocalStorage无法解决的程度，就可以用IndexDB来解决</p> <h2 id="cdn相关"><a href="#cdn相关" class="header-anchor">#</a> CDN相关</h2> <h3 id="cdn是什么"><a href="#cdn是什么" class="header-anchor">#</a> CDN是什么</h3> <p>CDN是一组分布在各个地区的服务器。这些服务器保存着数据的副本，这样服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。</p> <h3 id="cdn的核心功能"><a href="#cdn的核心功能" class="header-anchor">#</a> CDN的核心功能</h3> <h4 id="缓存"><a href="#缓存" class="header-anchor">#</a> 缓存</h4> <p>缓存就是我们把资源拷贝一份到CDN服务器（除了根服务器的其他服务器）上</p> <h4 id="回源"><a href="#回源" class="header-anchor">#</a> 回源</h4> <p>回源就是指CDN发现自己没有某个资源（或者缓存的资源过期），则转头去向根服务器去获取这个资源</p> <h4 id="场景"><a href="#场景" class="header-anchor">#</a> 场景</h4> <p>一般是静态资源才会走CDN，因为静态资源本身具有访问频率高、承接流量大的特点</p> <h4 id="cdn的域名带来的优化"><a href="#cdn的域名带来的优化" class="header-anchor">#</a> CDN的域名带来的优化</h4> <p>把静态资源和主页面置于不同的域名下，完美地避免了不必要的 Cookie 的出现！</p> <h2 id="服务端渲染和客户端渲染"><a href="#服务端渲染和客户端渲染" class="header-anchor">#</a> 服务端渲染和客户端渲染</h2> <h3 id="客户端渲染"><a href="#客户端渲染" class="header-anchor">#</a> 客户端渲染</h3> <p>客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。这种特性使得客户端渲染的源代码总是特别简洁，页面上呈现的内容，你在 html 源文件里里找不到——这正是它的特点。</p> <h3 id="服务端渲染"><a href="#服务端渲染" class="header-anchor">#</a> 服务端渲染</h3> <p>服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串， 然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了 生成 DOM 内容自己再去跑一遍 JS 代码。 使用服务端渲染的网站，可以说是“所见即所得”，页面上呈现的内容，我们在 html 源文件里也能找到。</p> <h3 id="服务端渲染解决的问题"><a href="#服务端渲染解决的问题" class="header-anchor">#</a> 服务端渲染解决的问题</h3> <ul><li><p>有利于SEO</p></li> <li><p>加快首屏渲染</p></li></ul> <h3 id="服务端应用场景"><a href="#服务端应用场景" class="header-anchor">#</a> 服务端应用场景</h3> <p>服务端渲染本质上是本该浏览器做的事情，分担给服务器去，除非网页对性能要求太高了，以至于所有的招式都用完了，性能表现还是不尽人意，才考虑服务端渲染。</p> <h2 id="浏览器渲染相关"><a href="#浏览器渲染相关" class="header-anchor">#</a> 浏览器渲染相关</h2> <h3 id="浏览器内核的核心部件"><a href="#浏览器内核的核心部件" class="header-anchor">#</a> 浏览器内核的核心部件</h3> <h4 id="html-解释器"><a href="#html-解释器" class="header-anchor">#</a> HTML 解释器</h4> <p>将 HTML 文档经过词法分析输出 DOM 树。</p> <h4 id="css-解释器"><a href="#css-解释器" class="header-anchor">#</a> CSS 解释器</h4> <p>解析 CSS 文档, 生成样式规则。</p> <h4 id="图层布局计算模块"><a href="#图层布局计算模块" class="header-anchor">#</a> 图层布局计算模块</h4> <p>布局计算每个对象的精确位置和大小。</p> <h4 id="视图绘制模块"><a href="#视图绘制模块" class="header-anchor">#</a> 视图绘制模块</h4> <p>进行具体节点的图像绘制，将像素渲染到屏幕上。</p> <h4 id="javascript-引擎"><a href="#javascript-引擎" class="header-anchor">#</a> JavaScript 引擎</h4> <p>编译执行 Javascript 代码。</p> <h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="header-anchor">#</a> 浏览器渲染过程</h3> <h4 id="解析html"><a href="#解析html" class="header-anchor">#</a> 解析HTML</h4> <p>在这一步浏览器将HTML文件从上至下解析，过程中会加载页面渲染所需的各种外部资源请求，如css,js，图片等。在这一步会生成DOM树。</p> <h4 id="计算样式"><a href="#计算样式" class="header-anchor">#</a> 计算样式</h4> <p>浏览器识别并加载CSS样式，解析生成CSSOM树（该解析过程是与DOM的解析并行的）并与DOM树合并，最终在页面生成render渲染树（注意：伪元素会被构建到DOM树中）。</p> <h4 id="计算图层布局"><a href="#计算图层布局" class="header-anchor">#</a> 计算图层布局</h4> <p>从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕 上的精确坐标，我们便得到了基于渲染树的布局渲染树。</p> <h4 id="绘制图层"><a href="#绘制图层" class="header-anchor">#</a> 绘制图层</h4> <p>浏览器根据DOM代码结果，把每一个页面图层转换为像素，并对所有媒体文件解码。</p> <h4 id="整合图层得到页面"><a href="#整合图层得到页面" class="header-anchor">#</a> 整合图层得到页面</h4> <p>合并所有图层，将数据从CPU输出至GPU并绘制到屏幕上。</p> <h3 id="css优化"><a href="#css优化" class="header-anchor">#</a> CSS优化</h3> <h4 id="小知识"><a href="#小知识" class="header-anchor">#</a> 小知识</h4> <p>CSS 引擎查找样式表，对每条规则都 按从右到左的顺序去匹配，比如#box li{}，这种写法在浏览器中是先找到所有的li元素，再查看他的父元素的id是否为box，而不是按我们的常规思路先定位id 再在id里面找。</p> <h4 id="优化点"><a href="#优化点" class="header-anchor">#</a> 优化点</h4> <ul><li><p>避免使用通配符，只对需要用到的元素进行选择。</p></li> <li><p>关注可以通过继承实现的属性，避免重复匹配重复定义。</p></li> <li><p>少用标签选择器。如果可以，用类选择器替代。</p></li> <li><p>减少嵌套。后代选择器的开销是高的，因此我们应该尽量将选择器的深度降到低（高不要超 过三层），尽可能使用类来关联每一个标签元素。</p></li></ul> <h3 id="css与js的加载顺序优化"><a href="#css与js的加载顺序优化" class="header-anchor">#</a> CSS与JS的加载顺序优化</h3> <h4 id="css的阻塞"><a href="#css的阻塞" class="header-anchor">#</a> CSS的阻塞</h4> <p>DOM 和 CSSOM 合力才能构建渲染树。这一点会给性能造成严重影响：默认情况下，CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。即便 DOM 已经解析完毕了，只要 CSSOM 没构建完成，那么就不能渲染。（这样的好处是避免了没有样式的页面显示）</p> <h4 id="css的加载优化"><a href="#css的加载优化" class="header-anchor">#</a> CSS的加载优化</h4> <p>为了达到更快渲染页面的目的，应该让CSS尽快的加载，而CSS的引入是通过link或者style的方式来进行的（都放在head里面为了尽快加载），然后资源放在CDN上，尽快的下载。</p> <h4 id="js阻塞"><a href="#js阻塞" class="header-anchor">#</a> JS阻塞</h4> <p>JS 引擎是独立于渲染引擎存在的。我们的 JS 代码在文档的何处插入，就在何处执行。 所以当HTML解析器加载到script标签时，会暂停渲染过程，将控制器交给JS引擎，这就导致了阻塞。</p> <h4 id="js的加载优化"><a href="#js的加载优化" class="header-anchor">#</a> JS的加载优化</h4> <h5 id="defer"><a href="#defer" class="header-anchor">#</a> defer</h5> <p>在script添加defer属性，可以让JS的加载变成异步，等整个文档解析完成，被标记了defer的JS文件才开始依次执行</p> <h5 id="async"><a href="#async" class="header-anchor">#</a> async</h5> <p>在script标签添加async属性，，也是异步加载JS，不过是加载结束就立即执行，而不用等文档加载完成，且不会保证执行顺序。</p> <h5 id="应用选择"><a href="#应用选择" class="header-anchor">#</a> 应用选择</h5> <p>一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。</p> <h4 id="回流与重绘"><a href="#回流与重绘" class="header-anchor">#</a> 回流与重绘</h4> <h5 id="回流"><a href="#回流" class="header-anchor">#</a> 回流</h5> <p>当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素 等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响）， 然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。 如背景色、文字色、可见性(可见性这里特指形如<code>visibility: hidden</code>这样不改变元素位置和存在 性的、单纯针对可见性的操作，注意与display:none进行区分)等都会触发回流。</p> <p><strong>注意</strong>：<code>oﬀsetTop、oﬀsetLeft、 oﬀsetWidth、oﬀsetHeight、scrollTop、 scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight， getComputedStyle</code> 这些值有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流。</p> <h4 id="重绘"><a href="#重绘" class="header-anchor">#</a> 重绘</h4> <p>当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回 流环节）。这个过程叫做重绘。</p> <h5 id="关系"><a href="#关系" class="header-anchor">#</a> 关系</h5> <p>回流一定会引发重绘，重绘不一定会引发回流。</p> <h4 id="优化切入点"><a href="#优化切入点" class="header-anchor">#</a> 优化切入点</h4> <p>考虑JS 的运行速度，比 DOM 快得多这个特性。我们减少 DOM 操作的核心思路，就是让 JS 去给 DOM 分压。</p> <h4 id="documentfragment"><a href="#documentfragment" class="header-anchor">#</a> DocumentFragment</h4> <p>DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作 （reﬂow），且不会导致性能等问题。</p> <h4 id="规避回流与重绘"><a href="#规避回流与重绘" class="header-anchor">#</a> 规避回流与重绘</h4> <ul><li><p>避免逐条改变样式，使用类名去合并样</p></li> <li><p>用JS缓存修改结果再赋值给DOM引发最终的变化。</p></li> <li><p>将 DOM “离线” ，即在修改的时候先设置为<code>display:none</code>，相当于从页面中拿掉，改完之后再变回来</p></li> <li><p>Flush 队列，浏览器自己缓存了一个 ﬂush 队列，把我们触发的回流与重绘任务都塞进 去，待到队列里的任务多起来、或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队（即时性的任务flush队列会不生效）</p></li></ul> <h4 id="event-loop-与异步更新策略"><a href="#event-loop-与异步更新策略" class="header-anchor">#</a> Event Loop 与异步更新策略</h4> <h5 id="event-loop过程"><a href="#event-loop过程" class="header-anchor">#</a> Event Loop过程</h5> <p><a href="https://xiaolee55.github.io/pages/Javascript/JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html" target="_blank" rel="noopener noreferrer">看这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h5 id="特点-6"><a href="#特点-6" class="header-anchor">#</a> 特点</h5> <p>异步更新的特性在于它只看结果，因此渲染引擎不需要为过程买单。</p> <p><img src="https://s2.ax1x.com/2020/02/06/1cuhqA.png" alt="1cuhqA.png"></p> <h5 id="dom修改应该放在哪"><a href="#dom修改应该放在哪" class="header-anchor">#</a> DOM修改应该放在哪</h5> <p>我们更新 DOM 的时间点，应该尽可能靠近渲染的时机。当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择。 因为如果放在macro-task中，macro-task会一个个地执行，如果DOM的异步更新是写在比较靠后的macro-task中，会导致在前面宏任务渲染的时候没有其效果。</p> <blockquote><p>由于性能优化方面一直是自己的一个知识盲区，所以在掘金上购买了一本相关的小册进行学习，虽然讲解不算很深入，但是比较全面，算是对性能优化有了一个整体的认识，后面再慢慢深入实践。</p></blockquote> <p><strong>完!</strong></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/pages/Javascript/JS中的生成器和Promise.html" class="prev">JS中的生成器和Promise</a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8d8834a2.js" defer></script><script src="/assets/js/2.4111b689.js" defer></script><script src="/assets/js/13.85dd6f14.js" defer></script>
  </body>
</html>
