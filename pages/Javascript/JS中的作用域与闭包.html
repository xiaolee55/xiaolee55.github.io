<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>XiaoLeeBlog</title>
    <meta name="description" content="我的文章网站">
    <link rel="icon" href="/titlelogo.png">
    
    <link rel="preload" href="/assets/css/0.styles.ec507139.css" as="style"><link rel="preload" href="/assets/js/app.8d8834a2.js" as="script"><link rel="preload" href="/assets/js/2.4111b689.js" as="script"><link rel="preload" href="/assets/js/8.a14ac5eb.js" as="script"><link rel="prefetch" href="/assets/js/10.f5b7094d.js"><link rel="prefetch" href="/assets/js/11.06b0a1b9.js"><link rel="prefetch" href="/assets/js/12.a29a4b4d.js"><link rel="prefetch" href="/assets/js/13.85dd6f14.js"><link rel="prefetch" href="/assets/js/14.e058b9f1.js"><link rel="prefetch" href="/assets/js/15.fa0a1b7f.js"><link rel="prefetch" href="/assets/js/16.c674646e.js"><link rel="prefetch" href="/assets/js/3.f0f9c942.js"><link rel="prefetch" href="/assets/js/4.9eed5240.js"><link rel="prefetch" href="/assets/js/5.d37db87a.js"><link rel="prefetch" href="/assets/js/6.64a418b3.js"><link rel="prefetch" href="/assets/js/7.331065bf.js"><link rel="prefetch" href="/assets/js/9.7e7c1c97.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ec507139.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/fe.png" alt="XiaoLeeBlog" class="logo"> <span class="site-name can-hide">XiaoLeeBlog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章" class="dropdown-title"><span class="title">文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Javascript/JS中的作用域与闭包.html" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/pages/HTML与CSS/BFC的理解与运用.html" class="nav-link">HTML与CSS</a></li></ul></div></div><div class="nav-item"><a href="/pages/folder1/test3.html" class="nav-link">我的项目</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="读书笔记" class="dropdown-title"><span class="title">读书笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/读书笔记/图解HTTP/http方法.html" class="nav-link">图解HTTP</a></li><li class="dropdown-item"><!----> <a href="/pages/读书笔记/图解HTTP/http方法.html" class="nav-link">JS忍者秘籍</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/xiaolee55" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章" class="dropdown-title"><span class="title">文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Javascript/JS中的作用域与闭包.html" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/pages/HTML与CSS/BFC的理解与运用.html" class="nav-link">HTML与CSS</a></li></ul></div></div><div class="nav-item"><a href="/pages/folder1/test3.html" class="nav-link">我的项目</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="读书笔记" class="dropdown-title"><span class="title">读书笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/读书笔记/图解HTTP/http方法.html" class="nav-link">图解HTTP</a></li><li class="dropdown-item"><!----> <a href="/pages/读书笔记/图解HTTP/http方法.html" class="nav-link">JS忍者秘籍</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/xiaolee55" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaScript基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/Javascript/JS中的作用域与闭包.html" class="active sidebar-link">JS中的作用域与闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Javascript/JS中的作用域与闭包.html#作用域" class="sidebar-link">作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Javascript/JS中的作用域与闭包.html#作用域是什么" class="sidebar-link">作用域是什么</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/JS中的作用域与闭包.html#作用域分为哪些" class="sidebar-link">作用域分为哪些</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/JS中的作用域与闭包.html#作用域链" class="sidebar-link">作用域链</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/JS中的作用域与闭包.html#js无块级作用域" class="sidebar-link">JS无块级作用域</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/JS中的作用域与闭包.html#声明提升" class="sidebar-link">声明提升</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/Javascript/JS中的作用域与闭包.html#作用域闭包" class="sidebar-link">作用域闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Javascript/JS中的作用域与闭包.html#闭包是什么" class="sidebar-link">闭包是什么</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/JS中的作用域与闭包.html#闭包的特性" class="sidebar-link">闭包的特性</a></li><li class="sidebar-sub-header"><a href="/pages/Javascript/JS中的作用域与闭包.html#闭包的应用场景" class="sidebar-link">闭包的应用场景</a></li></ul></li></ul></li><li><a href="/pages/Javascript/JS中的值传递.html" class="sidebar-link">JS中的值传递</a></li><li><a href="/pages/Javascript/JS中的事件循环.html" class="sidebar-link">JS中的事件循环</a></li><li><a href="/pages/Javascript/JS中的对象访问控制.html" class="sidebar-link">JS中的对象访问控制</a></li><li><a href="/pages/Javascript/JS中的类型判断.html" class="sidebar-link">JS中的类型判断</a></li><li><a href="/pages/Javascript/JS中的生成器和Promise.html" class="sidebar-link">JS中的生成器和Promise</a></li><li><a href="/pages/Javascript/掘金小册《前端性能优化原理与实践》阅读总结.html" class="sidebar-link">掘金小册《前端性能优化原理与实践》阅读总结.md</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><code>最近在看《你不知道的JavaScript》的第一卷，写文章总结一下自己的感悟。</code></p> <h2 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h2> <h3 id="作用域是什么"><a href="#作用域是什么" class="header-anchor">#</a> 作用域是什么</h3> <p>作用域本质就是程序源代码中定义变量的区域，它可以解释为一套规则，是关于JS引擎如何寻找变量以及会在何处找到变量的规则。</p> <h3 id="作用域分为哪些"><a href="#作用域分为哪些" class="header-anchor">#</a> 作用域分为哪些</h3> <p>从大的方面来讲，作用域分为两种，分别是词法作用域和动态作用域，两者的区别是词法作用域是在写代码时就确定了作用域（不使用eval和with的前提下，这两个现在基本不使用，因此不讲了），即静态作用域，而动态作用域是在代码运行时动态确定的。包括JS在内的大部分语言都是使用词法作用域，但是JS中有个东西很像动态作用域，就是this，因为它的值也是动态改变的。用代码简单对比一下两种作用域如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment">//输出2,假设JS是动态作用域，那么这里会输出3，但事实告诉我们显然不是</span>
 <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
 <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>因为JS是用词法作用域的，所以下面都称为作用域。JS中作用域又分为两种，<strong>全局作用域和函数作用域</strong>，作用域间都会存在作用域嵌套，这也是存在作用域链的前提，所以在引用一个变量时，要么在本函数作用域找到，要么在其父级作用域找到（可能是全局作用域或函数作用域）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">funA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">funB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//输出2</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//报错</span>
</code></pre></div><p>上面这段代码就存在一个嵌套的作用域，全局作用域嵌套函数A的作用域，函数A的作用域嵌套函数B的作用域，内层函数可以访问外层作用域，外层作用域无法访问内层作用域。</p> <ul><li><strong>标识符查找</strong></li></ul> <p>标识符查找分为LHS查询和RHS查询，一般来说LHS查询是为了为一个变量赋值而进行的查询，比如<code>a=2</code>,就是要找到a并给它赋值，如果根据作用域一直找到全局作用域都没找到，那么将会在全局定义一个变量a，如下面代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">console</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出2</span>
</code></pre></div><p>RHS查询则是想单纯找到这个变量并获取它的值，比如<code>console.log(a)</code>，如果一直找到全局作用域还没找到该变量，就会抛出错误，如下面代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">console</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//报错</span>
</code></pre></div><p>基本上代码中每一条语句都离不开标识符的查找，简单来讲，当执行某行代码需要进行LHS查询或者RHS查询时，会先在本函数的作用域内进行查询，如果查询到则立刻停止查询并将找到的值赋予需求代码，就算外面有同名标识符也没用，即查询将在遇到第一个符合的标识符时停止。看下面的例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> b<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面代码中<code>console.log(c)</code>需要进行c的RHS查询，路径很简单，直接在test2的内找到c并终止查询，就算全局环境有同名变量也没用，<code>console.log(a)</code>则是先在test2内查询，没找到，继续往test1找，还是没找到，最后在全局作用域找到a。</p> <h3 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h3> <p>先说两个概念：</p> <ul><li>执行环境：也可以叫执行上下文，这里定义了变量或函数有权访问的其他数据，当一个函数被执行时，他的执行环境会被推入环境栈，执行之后才会被弹出，把控制权返回给之前的执行环境。</li> <li>变量对象：每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中（变量对象其实就是作用域这个抽象概念的具体值），比如一个函数中包含的局部变量，它的参数，它里面声明的函数都存在变量对象中。（一个当前执行函数的变量对象最开始时就包含一个arguments对象，这个对象用来装函数括号内的参数，所以全局环境的变量对象没有这个）</li></ul> <p>（执行环境随着函数调用和返回不断重建和销毁，变量对象在某些情况下（比如闭包）可以一直维持）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> c<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//输出2</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre></div><p>说一下上面这个程序发生了什么，当test函数被创建时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]（可在控制台打印函数原型找到）属性中。当调用test函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]的属性中的对象构建起执行环境的作用域链，然后创建test函数的变量对象并推入执行环境作用域链的前端，所以对test函数的执行环境来说，其作用域链有两个变量对象：本函数变量对象和全局变量对象。</p> <p>那么作用域链是什么呢？<strong>作用域链实际上是指向变量对象的指针列表，它只引用但不实际包含变量对象</strong>，它的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的最前端始终都是当前执行的代码所在环境的变量对象，标识符的解析就是沿着作用域链一级级往上找，先是本函数的变量对象，没找到再到上一个包含环境的变量对象，直到全局环境。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/7/15/16bf5d99947ac9e9?w=583&amp;h=271&amp;f=png&amp;s=24400" alt="">
上面代码的说明图</p> <h3 id="js无块级作用域"><a href="#js无块级作用域" class="header-anchor">#</a> JS无块级作用域</h3> <p>在ES6之前，JS这门语言是不存在块级作用域的，如下面的代码</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> color<span class="token operator">=</span><span class="token string">&quot;blue&quot;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出blue</span>
</code></pre></div><p>如果是在其他有块级作用域的语言，将会因找不到color而报错，但是JS不会，这里又涉及到一个叫“变量提升的概念”，即JS引擎在执行这段代码时，会将<code>var color=&quot;blue&quot;</code>分为两句执行，即<code>var color</code>和<code>color=blue</code>，而声明变量会被提升到离自己最近的函数作用域或者全局作用域，所以上面的程序实际上是一下这样的：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code> <span class="token keyword">var</span> color<span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   color<span class="token operator">=</span><span class="token string">&quot;blue&quot;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出blue</span>
</code></pre></div><p>这也是为什么在if外部能打印出变量的值</p> <p>没有块级作用域为开发带来了许多麻烦，所以ES6中引入了let（还有const），用let声明的变量可以将变量绑定在所在的任意作用域中（包括块级作用域），如下</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> color<span class="token operator">=</span><span class="token string">&quot;blue&quot;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出blue</span>
</code></pre></div><p><img src="https://user-gold-cdn.xitu.io/2019/7/15/16bf46c775ff6e35?w=455&amp;h=23&amp;f=png&amp;s=3083" alt="">
以上代码会输出这个错误，这也证明了用了let的块级作用域是生效的</p> <h3 id="声明提升"><a href="#声明提升" class="header-anchor">#</a> 声明提升</h3> <p>首先我们知道，JS引擎在解释代码前会先对其进行编译，编译阶段有一个步骤就是先找到所有声明并将它们关联起来，看到<code>var a=2</code>，上面也提到这会分成两句，即<code>var a</code>和<code>a=2</code>,前者在编译阶段进行，后者则留在原地，即<code>var a</code>才能称为声明。</p> <p>函数声明也会被提升，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出111</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果没有提升，按照JS的顺序执行，应该先执行test，这时候会因为没找到test而报错，但实际没有，所以实际代码等同于下面这段：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出111</span>
</code></pre></div><p>函数表达式不会被提升，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//报错TypeError</span>
<span class="token keyword">var</span> <span class="token function-variable function">test</span><span class="token operator">=</span><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">console</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>报的错为什么是<code>TypeError</code>而不是<code>ReferenceError</code>呢，很显然，这是因为test这个变量被提升了，但是当执行<code>test();</code>时test的值还是<code>undefined</code>,对<code>undefined</code>进行函数调用就出现了类型错误，因此报了<code>TypeError</code>错误</p> <p>拓展小知识</p> <ul><li><p>如果出现同名的变量和函数声明，那么函数将会覆盖掉变量，当做该变量不存在；</p></li> <li><p>如果出现两个同名函数，那么后面的函数覆盖前一个函数；</p></li> <li><p>如果出现两个同名变量，新声明的会被忽略</p></li></ul> <p>（都是建立在用var声明的基础上，如果用let以上的情况会直接报错）</p> <ul><li>函数在条件语句中声明会作为函数表达式处理，因此不会有声明提升</li></ul> <h2 id="作用域闭包"><a href="#作用域闭包" class="header-anchor">#</a> 作用域闭包</h2> <h3 id="闭包是什么"><a href="#闭包是什么" class="header-anchor">#</a> 闭包是什么</h3> <p>一个函数和这个函数内部能访问到的变量总称为闭包，看下面这个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>就是这么段简单代码，其实就可以称为闭包了，因为test函数一直持有对a变量的引用，但通过上面对词法作用域的了解，我们更愿意将其理解为词法作用域的查找规则：在本函数作用域内没有找到该变量，转而到父级作用域中寻找。但是闭包！=词法作用域的查找规则，上面的代码也只是闭包的其中一种。
这段代码不能直接观察到闭包，所以我们来一个常见且清晰的闭包：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">funA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">funB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> funB<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> test<span class="token operator">=</span><span class="token function">funA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出2</span>
</code></pre></div><p>上面这段代码更能诠释闭包，和上面的例子不同，我们不是在funB被定义的作用域调用它，而是在外部的作用域调用了它，通过这个方式，我们就能顺利的在全局作用域访问funA的内部变量，这似乎和我们上面说的词法作用域的规则--“内部作用域可以访问外部作用域，反过来不行”相违背，但是我们却真的做到了，而且运用的就是词法作用域的规则，因为funB是funA的内部函数，所以funB访问funA的内部变量毫无问题，这就和函数访问某个全局变量一样再正常不过。这就是闭包的强大之处。</p> <h3 id="闭包的特性"><a href="#闭包的特性" class="header-anchor">#</a> 闭包的特性</h3> <p>我们知道，通常一个函数在执行完之后，其内部的变量都会被垃圾回收器进行回收，但是闭包函数不会。比如上面那个例子，当执行完<code>var test=funA();</code>之后，a变量也不会被垃圾回收器回收，因为funB函数还持有其引用，因为不确定是否会再次使用a，所以a变量会一直保持着，因此滥用闭包会导致内存泄露。</p> <h3 id="闭包的应用场景"><a href="#闭包的应用场景" class="header-anchor">#</a> 闭包的应用场景</h3> <ol><li>解决for循环中的重复绑定问题，如下：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们预想的是每秒都打印出一个不同的数字，从1到5，但结果是每秒都输出一个6，其实用词法作用域的工作原理去理解很容易就知道为什么：var没有块级作用域，因此每个函数共享全局作用域中的变量i，即使发生了循环，因为每次循环没有暂存变量，所以都是等待最终循环结束后才会对延迟函数进行调用，或许你会觉得我用最短的时间执行函数就行了，那你可以把上面的1000换成0试试看，结果还是不变，实际上这段代码等同于下面：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">delay</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">delay</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">delay</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>
    <span class="token operator">...</span>
</code></pre></div><p>那用闭包怎么解决这个问题呢，实际上很容易，只要在每次循环都创建一个全新的作用域就行了，如下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的代码在setTimeout外面加了一层IIFE（立即执行）函数，将每次循环的i的值都保存起来，因此setTimeout中的函数寻找i时会先在IIFE中寻找，这样就能产生不同的i值了。 当然现在已经有更方便的let解决这个问题了，所以使用这个主要还是学习其思想。</p> <p>2.用来实现模块机制
我们可以利用闭包形成私有的变量和公共接口，已达成实现模块的功能，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">funA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> b<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">getB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        getA<span class="token punctuation">:</span> getA<span class="token punctuation">,</span>
        getB<span class="token punctuation">:</span> getB
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
funA<span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
funA<span class="token punctuation">.</span><span class="token function">getB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面的例子我们在外部不能直接修改或访问funA内部的值，但是我们可以通过别人提供的接口进行访问，这样就能起到保护变量但是又能访问变量的效果，实际上就是实现了面向对象中类的效果。上面只是个简单例子，更多复杂的就不在这里讲了，因为自己也没了解过，以后学到了再回来补齐。</p> <p><code>这篇文章就到这里了，第一次写这么长，写的过程又扎实了不少，果然看书自以为的理解不是理解，能够自己叙述出来才是硬道理，很多地方的表达都是借鉴书上的，如果有人看并觉得有问题的欢迎指正和讨论</code></p> <ul><li>参考书籍：《你不知道的JS》上卷，红宝书</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/pages/Javascript/JS中的值传递.html">JS中的值传递</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8d8834a2.js" defer></script><script src="/assets/js/2.4111b689.js" defer></script><script src="/assets/js/8.a14ac5eb.js" defer></script>
  </body>
</html>
